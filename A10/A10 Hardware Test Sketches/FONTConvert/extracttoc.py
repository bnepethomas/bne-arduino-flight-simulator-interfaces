# 20240216 Now need to roll though all didgts and create array with correct headings etc
#
# Reads in a BMP file and outputs an array that can be printed on epaper
# The BMP File is a strip of characters that were individually created
# from windows paint wiith the correct bitmap size. The the Altimeter
# the size of the bitmap is 48*48 bits, which is 2304 bits total (288 Bytes)
#
# This font is wider than usual to emulate the gap between the wheels
# which fortunately means it can be flipped, without any changes
#
# The sample code generated by chatgpt has 8 bits per pixel, which doesn't
# map to the one bit per pixel so now read 8 pixels into a byte

# Headers
##const unsigned char Num[10][192] PROGMEM= {
##//0
##{
##   0XFF,0XFF,0XFF,0XFF
##},
##//1
##{

from PIL import Image

from datetime import datetime



def extract_bmp_part(input_file, output_file, x, y, width, height):
    # Open the BMP file
    img = Image.open(input_file)

    # Crop the image to extract the specified part
    cropped_img = img.crop((x, y, x + width, y + height))

    # Save the cropped image
    cropped_img.save(output_file)

def write_c_header(output_file, element_count):
    with open(output_file, 'w') as f:
        f.write('// Oz Hornet Font File\n')
        now = datetime.now() # current date and time
        f.write('// Generated ' + now.strftime("%m/%d/%Y, %H:%M:%S")  + '\n')
        # Need to validate number of array elements
        f.write('const unsigned char petetest[' + str(element_count) + '][288]PROGMEM={\n')  

def write_c_footer(output_file):
    with open(output_file, 'a') as f:
        f.write('};\n')


def export_to_c_format(image_data, width, height, output_file):
    with open(output_file, 'a') as f:


        # This code is mapping a pixel to a byte - needs to map 8 pixels to a byte
        # working with one byte per pixel
        # print(type(image_data[0]))
        if (type(image_data[0]) is int):
            print("Working with Image Data Type of Int")
        elif (type(image_data[0]) is tuple):
            print("Working with Image Data Type of Tuple")
        else:
            print("working with untest type of " + type(image_data[0]))
        f.write(f'// image_width = {width};\n')
        f.write(f'// image_height = {height};\n')
        f.write('{\n')
        for y in range(height):

            # 1 Bit per pixel
            if (type(image_data[0]) is int):
                for x in range(0,width,8):
                                    
                    pixel_0 = image_data[y * width + x]
                    if (pixel_0 == 0):
                        pixel_0 = 1
                    else:
                        pixel_0 = 0
                    #print("Pixel_0 = " + str(pixel_0))
                    
                    pixel_1 = image_data[y * width + x + 1]
                    if (pixel_1 == 0):
                        pixel_1 = 1
                    else:
                        pixel_1 = 0
                    #print("Pixel_1 = " + str(pixel_1))
                    
                    pixel_2 = image_data[y * width + x + 2]
                    if (pixel_2 == 0):
                        pixel_2 = 1
                    else:
                        pixel_2 = 0
                    #print("Pixel_2 = " + str(pixel_2))
                    
                    pixel_3 = image_data[y * width + x + 3]
                    if (pixel_3 == 0):
                        pixel_3 = 1
                    else:
                        pixel_3 = 0
                    #print("Pixel_3 = " + str(pixel_3))
                    
                    pixel_4 = image_data[y * width + x + 4]
                    if (pixel_4 == 0):
                        pixel_4 = 1
                    else:
                        pixel_4 = 0
                    #print("Pixel_4 = " + str(pixel_4))
                    
                    pixel_5 = image_data[y * width + x + 5]
                    if (pixel_5 == 0):
                        pixel_5 = 1
                    else:
                        pixel_5 = 0                
                    #print("Pixel_5 = " + str(pixel_5))

                        
                    pixel_6 = image_data[y * width + x + 6]
                    if (pixel_6 == 0):
                        pixel_6 = 1
                    else:
                        pixel_6 = 0
                    
                    #print("Pixel_6 = " + str(pixel_6))
                    
                    pixel_7 = image_data[y * width + x + 7]
                    if (pixel_7 == 0):
                        pixel_7 = 1
                    else:
                        pixel_7 = 0               
                    #print("Pixel_7 = " + str(pixel_7))

                    pixel = pixel_0 * 128 + pixel_1 * 64 + pixel_2 * 32 + pixel_3 * 16 + pixel_4 * 8 + pixel_5 * 4 + pixel_6 * 2 + pixel_7
                
                    f.write(f'0x{pixel:02X}, ')

            if (type(image_data[0]) is tuple):
                # Working with 3 bytes per pixel ie an array of 3
                for x in range(0,width,8):
                    
                                    
                    pixel_0 = image_data[y * width + x][0]
                    # print("Pixel " + str(pixel_0))
                    if (pixel_0 == 0):
                        pixel_0 = 1
                    else:
                        pixel_0 = 0
                    #print("Pixel_0 = " + str(pixel_0))
                    
                    pixel_1 = image_data[y * width + x + 1][0]
                    if (pixel_1 == 0):
                        pixel_1 = 1
                    else:
                        pixel_1 = 0
                    #print("Pixel_1 = " + str(pixel_1))
                    
                    pixel_2 = image_data[y * width + x + 2][0]
                    if (pixel_2 == 0):
                        pixel_2 = 1
                    else:
                        pixel_2 = 0
                    #print("Pixel_2 = " + str(pixel_2))
                    
                    pixel_3 = image_data[y * width + x + 3][0]
                    if (pixel_3 == 0):
                        pixel_3 = 1
                    else:
                        pixel_3 = 0
                    #print("Pixel_3 = " + str(pixel_3))
                    
                    pixel_4 = image_data[y * width + x + 4][0]
                    if (pixel_4 == 0):
                        pixel_4 = 1
                    else:
                        pixel_4 = 0
                    #print("Pixel_4 = " + str(pixel_4))
                    
                    pixel_5 = image_data[y * width + x + 5][0]
                    if (pixel_5 == 0):
                        pixel_5 = 1
                    else:
                        pixel_5 = 0                
                    #print("Pixel_5 = " + str(pixel_5))

                        
                    pixel_6 = image_data[y * width + x + 6][0]
                    if (pixel_6 == 0):
                        pixel_6 = 1
                    else:
                        pixel_6 = 0
                    
                    #print("Pixel_6 = " + str(pixel_6))
                    
                    pixel_7 = image_data[y * width + x + 7][0]
                    if (pixel_7 == 0):
                        pixel_7 = 1
                    else:
                        pixel_7 = 0               
                    #print("Pixel_7 = " + str(pixel_7))

                    pixel = pixel_0 * 128 + pixel_1 * 64 + pixel_2 * 32 + pixel_3 * 16 + pixel_4 * 8 + pixel_5 * 4 + pixel_6 * 2 + pixel_7
                
                    f.write(f'0x{pixel:02X}, ')
                    

                    
            f.write('\n')

        f.write('},\n')


if __name__ == "__main__":
    #input_file = "48-48-0.bmp"
    #input_file = "alldigits.bmp"
    input_file = "hashone.bmp"
    output_file = "scratchoutput.bmp"
    cropped_output_file = "cropped_output.bmp"
    c_output_file = "../GDEW0097T50_Arduino/ozhornet_epaper_font_data.h"
    c_output_file = "../GDEW0097T50_Arduino/ozhornet_epaper_hash_data.h"

    image_width = 48
    image_height = 48

    # number_of_elements = 80
    number_of_elements = 16

    # Write Header of output file
    write_c_header(output_file=c_output_file, element_count=number_of_elements)

    for i in range(0,(number_of_elements -1)):

        # Extract a part of the BMP file
        extract_bmp_part(input_file, cropped_output_file, x=0, y=(i * image_height/8), width=image_width, height=image_height)
        #extract_bmp_part(input_file, cropped_output_file, x=0, y=i, width=image_width, height=image_height)

        # Open the cropped BMP file and get its pixel data
        cropped_img = Image.open(cropped_output_file)

        # Adjust orentation for epaper
        rotated_img = cropped_img.transpose(method=Image.ROTATE_90)
        #flipped_img = rotated_img.transpose(Image.FLIP_TOP_BOTTOM)
        image_data = list(rotated_img.getdata())
        

        # Export the cropped image data to a C file
        export_to_c_format(image_data, width=48, height=48, output_file=c_output_file)




    # Write Footer of output file
    write_c_footer(output_file=c_output_file)
