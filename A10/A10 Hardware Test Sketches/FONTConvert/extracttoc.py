# 20240216 Now need to roll though all didgts and create array with correct headings etc
#
# Reads in a BMP file and outputs an array that can be printed on epaper
# The BMP File is a strip of characters that were individually created
# from windows paint wiith the correct bitmap size. The the Altimeter
# the size of the bitmap is 48*48 bits, which is 2304 bits total (288 Bytes)
#
# This font is wider than usual to emulate the gap between the wheels
# which fortunately means it can be flipped, without any changes
#
# The sample code generated by chatgpt has 8 bits per pixel, which doesn't
# map to the one bit per pixel so now read 8 pixels into a byte

# Headers
##const unsigned char Num[10][192] PROGMEM= {
##//0
##{
##   0XFF,0XFF,0XFF,0XFF
##},
##//1
##{

from PIL import Image

from datetime import datetime



def extract_bmp_part(input_file, output_file, x, y, width, height):
    # Open the BMP file
    img = Image.open(input_file)

    # Crop the image to extract the specified part
    cropped_img = img.crop((x, y, x + width, y + height))

    # Save the cropped image
    cropped_img.save(output_file)

def write_c_header(output_file):
    with open(output_file, 'w') as f:
        f.write('// Oz Hornet Font File\n')
        now = datetime.now() # current date and time
        f.write('// Generated ' + now.strftime("%m/%d/%Y, %H:%M:%S")  + '\n')
        f.write('const unsigned char petetest[288]PROGMEM={\n')  

def export_to_c_format(image_data, width, height, output_file):
    with open(output_file, 'a') as f:


        # This code is mapping a pixel to a byte - needs to map 8 pixels to a byte
        for y in range(height):

            if (False):
                for x in range(0,width,8):
                                    
                    pixel_0 = image_data[y * width + x]
                    if (pixel_0 == 0):
                        pixel_0 = 1
                    else:
                        pixel_0 = 0
                    #print("Pixel_0 = " + str(pixel_0))
                    
                    pixel_1 = image_data[y * width + x + 1]
                    if (pixel_1 == 0):
                        pixel_1 = 1
                    else:
                        pixel_1 = 0
                    #print("Pixel_1 = " + str(pixel_1))
                    
                    pixel_2 = image_data[y * width + x + 2]
                    if (pixel_2 == 0):
                        pixel_2 = 1
                    else:
                        pixel_2 = 0
                    #print("Pixel_2 = " + str(pixel_2))
                    
                    pixel_3 = image_data[y * width + x + 3]
                    if (pixel_3 == 0):
                        pixel_3 = 1
                    else:
                        pixel_3 = 0
                    #print("Pixel_3 = " + str(pixel_3))
                    
                    pixel_4 = image_data[y * width + x + 4]
                    if (pixel_4 == 0):
                        pixel_4 = 1
                    else:
                        pixel_4 = 0
                    #print("Pixel_4 = " + str(pixel_4))
                    
                    pixel_5 = image_data[y * width + x + 5]
                    if (pixel_5 == 0):
                        pixel_5 = 1
                    else:
                        pixel_5 = 0                
                    #print("Pixel_5 = " + str(pixel_5))

                        
                    pixel_6 = image_data[y * width + x + 6]
                    if (pixel_6 == 0):
                        pixel_6 = 1
                    else:
                        pixel_6 = 0
                    
                    #print("Pixel_6 = " + str(pixel_6))
                    
                    pixel_7 = image_data[y * width + x + 7]
                    if (pixel_7 == 0):
                        pixel_7 = 1
                    else:
                        pixel_7 = 0               
                    #print("Pixel_7 = " + str(pixel_7))

                    pixel = pixel_0 * 128 + pixel_1 * 64 + pixel_2 * 32 + pixel_3 * 16 + pixel_4 * 8 + pixel_5 * 4 + pixel_6 * 2 + pixel_7
                
                    f.write(f'0x{pixel:02X}, ')

            if (True):
                for x in range(width):
                    pixel = image_data[y * width + x]
                    print("Pixel = " + str(pixel[0]) + " " + str(pixel[1]) + " " + str(pixel[2]))
                    f.write(f'0x{pixel[0]:02X}, ')
                    

                    
            f.write('\n')

        f.write('};\n')
        f.write(f'// image_width = {width};\n')
        f.write(f'// image_height = {height};\n')

if __name__ == "__main__":
    #input_file = "48-48-0.bmp"
    input_file = "alldigits.bmp"
    output_file = "scratchoutput.bmp"
    # working through weird issue as alldigits.bmp gives all 0x00 but 48-48-0.bmp doesn't
    cropped_output_file = "cropped_output.bmp"
    c_output_file = "../GDEW0097T50_Arduino/ozhornet_epaper_font_data.h"

    # Extract a part of the BMP file
    extract_bmp_part(input_file, cropped_output_file, x=0, y=0, width=48, height=48)

    # Open the cropped BMP file and get its pixel data
    cropped_img = Image.open(cropped_output_file)

    # Adjust orentation for epaper
    rotated_img = cropped_img.transpose(method=Image.ROTATE_90)
    flipped_img = rotated_img.transpose(Image.FLIP_TOP_BOTTOM)
    image_data = list(flipped_img.getdata())

    # Export the cropped image data to a C file
    write_c_header(output_file=c_output_file)
    export_to_c_format(image_data, width=48, height=48, output_file=c_output_file)
